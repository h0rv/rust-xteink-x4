use std::env;
use std::fs;
use std::io::Write;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=assets/fonts/bookerly/Bookerly-Regular.ttf");
    println!("cargo:rerun-if-changed=assets/fonts/bookerly/Bookerly-Bold.ttf");
    println!("cargo:rerun-if-changed=assets/fonts/bookerly/Bookerly-Italic.ttf");
    println!("cargo:rerun-if-changed=assets/fonts/bookerly/Bookerly-BoldItalic.ttf");

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("embedded_fonts.rs");
    let mut f = fs::File::create(&dest_path).unwrap();

    // Font sizes to generate (in pixels)
    let sizes = vec![12u32, 14, 16, 18, 20];

    // ASCII + common Latin-1 characters
    let charset: Vec<char> = (0x20..=0x7E) // ASCII printable
        .chain(0xA1..=0xFF) // Latin-1 Supplement (excluding control chars)
        .map(|c| c as u8 as char)
        .collect();

    writeln!(f, "// Auto-generated by build.rs - DO NOT EDIT").unwrap();
    writeln!(f, "// Compile-time bitmap font data").unwrap();
    writeln!(f).unwrap();

    // Generate for each font variant with clean constant names
    generate_font(
        &mut f,
        "Regular",
        "assets/fonts/bookerly/Bookerly-Regular.ttf",
        &sizes,
        &charset,
    );
    generate_font(
        &mut f,
        "Bold",
        "assets/fonts/bookerly/Bookerly-Bold.ttf",
        &sizes,
        &charset,
    );
    generate_font(
        &mut f,
        "Italic",
        "assets/fonts/bookerly/Bookerly-Italic.ttf",
        &sizes,
        &charset,
    );
    generate_font(
        &mut f,
        "BoldItalic",
        "assets/fonts/bookerly/Bookerly-BoldItalic.ttf",
        &sizes,
        &charset,
    );

    // Generate font registry
    writeln!(f).unwrap();
    writeln!(
        f,
        "pub static EMBEDDED_FONTS: &[(&str, &[EmbeddedFontSize])] = &["
    )
    .unwrap();
    writeln!(f, "    (\"bookerly-regular\", BOOKERLY_REGULAR_SIZES),").unwrap();
    writeln!(f, "    (\"bookerly-bold\", BOOKERLY_BOLD_SIZES),").unwrap();
    writeln!(f, "    (\"bookerly-italic\", BOOKERLY_ITALIC_SIZES),").unwrap();
    writeln!(
        f,
        "    (\"bookerly-bold-italic\", BOOKERLY_BOLDITALIC_SIZES),"
    )
    .unwrap();
    writeln!(f, "];").unwrap();

    println!(
        "cargo:warning=Generated embedded bitmap fonts at {}",
        dest_path.display()
    );
}

fn generate_font(f: &mut fs::File, variant: &str, ttf_path: &str, sizes: &[u32], charset: &[char]) {
    // Read TTF file
    let font_data =
        fs::read(ttf_path).unwrap_or_else(|_| panic!("Failed to read font: {}", ttf_path));

    let font = fontdue::Font::from_bytes(font_data.as_slice(), fontdue::FontSettings::default())
        .unwrap_or_else(|_| panic!("Failed to parse font: {}", ttf_path));

    writeln!(f, "// Font: Bookerly {}", variant).unwrap();
    writeln!(f).unwrap();

    // Generate bitmap data for each size
    for &size in sizes {
        generate_size(f, variant, size, charset, &font);
    }

    // Generate size registry with simple naming
    writeln!(
        f,
        "pub static BOOKERLY_{}_SIZES: &[EmbeddedFontSize] = &[",
        variant.to_uppercase()
    )
    .unwrap();
    for &size in sizes {
        writeln!(f, "    EmbeddedFontSize {{").unwrap();
        writeln!(f, "        size_px: {},", size).unwrap();
        writeln!(
            f,
            "        font: &BOOKERLY_{}_{}_FONT,",
            variant.to_uppercase(),
            size
        )
        .unwrap();
        writeln!(f, "    }},",).unwrap();
    }
    writeln!(f, "];").unwrap();
    writeln!(f).unwrap();
}

fn generate_size(
    f: &mut fs::File,
    variant: &str,
    size: u32,
    charset: &[char],
    font: &fontdue::Font,
) {
    let const_prefix = format!("BOOKERLY_{}_{}", variant.to_uppercase(), size);

    // Collect glyph data
    let mut glyphs: Vec<GlyphData> = Vec::new();
    let mut bitmap_data: Vec<u8> = Vec::new();

    for &ch in charset {
        let (metrics, bitmap) = font.rasterize(ch, size as f32);

        if metrics.width == 0 || metrics.height == 0 {
            // Empty glyph (e.g., space)
            glyphs.push(GlyphData {
                codepoint: ch,
                width: 0,
                height: 0,
                advance_width: metrics.advance_width as u8,
                x_offset: 0,
                y_offset: 0,
                data_offset: 0,
                data_len: 0,
            });
        } else {
            // Pack bitmap data (1bpp: threshold at 128)
            let offset = bitmap_data.len() as u32;
            let packed = pack_bitmap_1bpp(&bitmap, metrics.width, metrics.height);
            let len = packed.len() as u32;
            bitmap_data.extend_from_slice(&packed);

            glyphs.push(GlyphData {
                codepoint: ch,
                width: metrics.width as u8,
                height: metrics.height as u8,
                advance_width: metrics.advance_width as u8,
                x_offset: metrics.xmin as i8,
                y_offset: metrics.ymin as i8,
                data_offset: offset,
                data_len: len,
            });
        }
    }

    // Write glyph metrics array
    writeln!(
        f,
        "static {}_GLYPHS: [EmbeddedGlyphMetrics; {}] = [",
        const_prefix,
        glyphs.len()
    )
    .unwrap();
    for g in &glyphs {
        writeln!(f, "    EmbeddedGlyphMetrics {{").unwrap();
        writeln!(f, "        codepoint: {},", g.codepoint as u32).unwrap();
        writeln!(f, "        width: {},", g.width).unwrap();
        writeln!(f, "        height: {},", g.height).unwrap();
        writeln!(f, "        advance_width: {},", g.advance_width).unwrap();
        writeln!(f, "        x_offset: {},", g.x_offset).unwrap();
        writeln!(f, "        y_offset: {},", g.y_offset).unwrap();
        writeln!(f, "        data_offset: {},", g.data_offset).unwrap();
        writeln!(f, "        data_len: {},", g.data_len).unwrap();
        writeln!(f, "    }},",).unwrap();
    }
    writeln!(f, "];").unwrap();
    writeln!(f).unwrap();

    // Write bitmap data array
    writeln!(
        f,
        "static {}_BITMAP_DATA: [u8; {}] = [",
        const_prefix,
        bitmap_data.len()
    )
    .unwrap();
    for chunk in bitmap_data.chunks(16) {
        write!(f, "    ").unwrap();
        for &byte in chunk {
            write!(f, "0x{:02X}, ", byte).unwrap();
        }
        writeln!(f).unwrap();
    }
    writeln!(f, "];").unwrap();
    writeln!(f).unwrap();

    // Write font struct
    let line_height = (size as f32 * 1.2) as u8;
    writeln!(
        f,
        "static {}_FONT: EmbeddedBitmapFont = EmbeddedBitmapFont {{",
        const_prefix
    )
    .unwrap();
    writeln!(f, "    size_px: {},", size).unwrap();
    writeln!(f, "    line_height: {},", line_height).unwrap();
    writeln!(f, "    glyph_count: {},", glyphs.len()).unwrap();
    writeln!(f, "    glyphs: &{}_GLYPHS,", const_prefix).unwrap();
    writeln!(f, "    bitmap_data: &{}_BITMAP_DATA,", const_prefix).unwrap();
    writeln!(f, "    bits_per_pixel: 1,").unwrap();
    writeln!(f, "}};").unwrap();
    writeln!(f).unwrap();
}

fn pack_bitmap_1bpp(bitmap: &[u8], width: usize, height: usize) -> Vec<u8> {
    let row_bytes = width.div_ceil(8); // Bytes per row, rounded up
    let mut packed = vec![0u8; row_bytes * height];

    for y in 0..height {
        for x in 0..width {
            let pixel_idx = y * width + x;
            if pixel_idx < bitmap.len() && bitmap[pixel_idx] > 128 {
                let byte_idx = y * row_bytes + (x / 8);
                let bit_idx = 7 - (x % 8); // MSB first
                packed[byte_idx] |= 1 << bit_idx;
            }
        }
    }

    packed
}

struct GlyphData {
    codepoint: char,
    width: u8,
    height: u8,
    advance_width: u8,
    x_offset: i8,
    y_offset: i8,
    data_offset: u32,
    data_len: u32,
}
