# einked — Core Specification

> A Rust UI framework for e-ink displays.  
> `no_std` · embedded-first · text-native · zero runtime tree

---

## Guiding Principles

1. **E-ink is not a slow LCD.** The refresh model is fundamentally different — the framework must treat rendering as deliberate, not continuous. Every design decision flows from this.
2. **Text is the primary citizen.** Unlike generic embedded UI toolkits, `einked` is designed for content-heavy interfaces. Layout, theming, and widget primitives are all text-aware by default.
3. **Developer experience over framework cleverness.** The API should be obvious to read, obvious to debug, and obvious to extend. No magic. No hidden allocations.
4. **Pay only for what you use.** `no_std` + `no_alloc` core. Optional features gate alloc-using conveniences. The firmware path and the simulator path use the same types.
5. **The compiler is the best runtime.** Type-state, phantom types, and traits do the work at compile time so the embedded target does as little as possible at runtime.

---

## Crate Structure

```
einked-core          # traits, types, activity model, layout, widgets, macros
einked-fonts         # glyph rasterization, LRU cache, fontdue backend
einked-epub          # bridges epub-stream-render into einked activities
```

Everything in `einked-core` is `no_std`. `einked-fonts` requires `alloc` for the glyph cache (configurable arena size). `einked-epub` requires `alloc`.

All three publish to crates.io independently. A device firmware picks what it needs.

---

## Layer Architecture

```
 ┌──────────────────────────────────────────────────────┐
 │                  ui! { } macro                       │  declarative DSL
 ├──────────────────────────────────────────────────────┤
 │            Activity / ActivityStack                  │  navigation model
 ├──────────────────────────────────────────────────────┤
 │         Layout Engine  │  Widget Traits              │  composition
 ├──────────────────────────────────────────────────────┤
 │    Render IR  │  DrawCmd buffer  │  DirtyTracker     │  diffing layer
 ├──────────────────────────────────────────────────────┤
 │           RefreshScheduler                           │  e-ink policy
 ├──────────────────────────────────────────────────────┤
 │     embedded-graphics DrawTarget  (user provides)    │  hardware
 └──────────────────────────────────────────────────────┘
```

Each layer only knows about the layer directly below it. The hardware driver is never imported by `einked-core`.

---

## Core Types

### `Rect` and `Point`

```rust
/// Axis-aligned bounding box. All layout produces Rects.
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct Rect {
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
}

impl Rect {
    pub fn split_top(self, height: u16) -> (Rect, Rect);
    pub fn split_bottom(self, height: u16) -> (Rect, Rect);
    pub fn split_left(self, width: u16) -> (Rect, Rect);
    pub fn split_right(self, width: u16) -> (Rect, Rect);
    pub fn inset(self, h: u16, v: u16) -> Rect;
    pub fn contains(self, p: Point) -> bool;
    pub fn intersects(self, other: Rect) -> bool;
    pub fn union(self, other: Rect) -> Rect;
}
```

`i16` coordinates — large enough for any realistic e-ink display (max ~1200px), small enough to pack two into a u32 for dirty region encoding.

### `Color`

```rust
/// Display-independent color. Backends convert to their native format.
#[derive(Copy, Clone, Debug, PartialEq)]
pub enum Color {
    Black,
    White,
    Gray(u8),    // 0=black, 255=white — dithered by backend if 1-bit display
    Red,         // for BWR tri-color displays
    Custom(u8),  // raw display value, escape hatch
}
```

### `TextStyle`

```rust
#[derive(Copy, Clone, Debug)]
pub struct TextStyle {
    pub font: FontId,          // opaque handle, resolved by GlyphRasterizer
    pub size_px: f32,
    pub color: Color,
    pub line_height: LineHeight, // Multiplier(f32) | Absolute(u16)
    pub letter_spacing: i8,    // pixels, can be negative
    pub weight: FontWeight,    // Regular | Bold
    pub style: FontStyle,      // Normal | Italic
}
```

`FontId` is just a `u8` index into a font registry the user provides at startup. No string lookups at render time.

### `Theme`

```rust
/// A complete set of TextStyles and Colors for a UI.
/// Users implement this trait to provide their own theme.
pub trait Theme {
    fn body(&self) -> TextStyle;
    fn heading(&self) -> TextStyle;
    fn caption(&self) -> TextStyle;
    fn ui_label(&self) -> TextStyle;  // menus, buttons, status bars
    fn background(&self) -> Color;
    fn foreground(&self) -> Color;
    fn accent(&self) -> Color;
}

/// Sensible defaults for a 1-bit e-ink display.
pub struct DefaultTheme;
impl Theme for DefaultTheme { ... }
```

The theme is passed into the `Ui` context at construction. Activities receive it via context. No global state.

---

## Input Model

### `InputEvent`

```rust
/// Logical input events. Hardware drivers map physical buttons to these.
#[derive(Copy, Clone, Debug, PartialEq)]
pub enum InputEvent {
    Left,
    Right,
    Up,
    Down,
    Confirm,
    Back,
    Power,
    // Escape hatch for device-specific events
    Custom(u8),
}
```

### `InputSource` trait

```rust
pub trait InputSource {
    /// Returns the next pending event, or None if no input.
    /// Must not block.
    fn poll(&mut self) -> Option<InputEvent>;
}
```

Device firmware implements this. Simulators implement it with keyboard/gamepad. `einked-core` never knows about ADC, GPIO, or any hardware.

---

## Activity Model

The activity model is the navigation backbone. Inspired by Android activities but stripped to the minimum needed for embedded.

### `Activity` trait

```rust
pub trait Activity<T: Theme> {
    /// Called once when the activity becomes the top of the stack.
    /// Use to initialize state, start timers, load data.
    fn on_enter(&mut self, ctx: &mut Context<T>);

    /// Called once when another activity is pushed on top.
    /// Use to pause background work.
    fn on_pause(&mut self, ctx: &mut Context<T>) {}

    /// Called when this activity returns to the top (after a Pop).
    fn on_resume(&mut self, ctx: &mut Context<T>) {}

    /// Called once before this activity is removed from the stack.
    fn on_exit(&mut self, ctx: &mut Context<T>) {}

    /// Handle an input event. Return a Transition.
    fn on_input(&mut self, event: InputEvent, ctx: &mut Context<T>) -> Transition;

    /// Render the current state into the Ui context.
    /// Called after input handling if the activity is dirty.
    fn render(&self, ui: &mut Ui<T>);

    /// Hint to the refresh scheduler for the next render.
    /// Default: Adaptive (scheduler decides based on dirty flags).
    fn refresh_hint(&self) -> RefreshHint {
        RefreshHint::Adaptive
    }
}
```

### `Transition`

```rust
pub enum Transition {
    /// Stay on this activity. Nothing changes.
    Stay,

    /// Push a new activity on top. Current activity pauses.
    Push(Box<dyn Activity<T>>),  // alloc feature
    // or:
    Push(&'static dyn ActivityFactory), // no_alloc alternative

    /// Remove this activity. Previous activity resumes.
    Pop,

    /// Replace this activity with a new one. No resume.
    Replace(Box<dyn Activity<T>>),

    /// Clear the entire stack and start fresh.
    Reset(Box<dyn Activity<T>>),
}
```

For `no_alloc` targets, `Push` and `Replace` use a user-provided static activity pool rather than boxing. The `alloc` feature enables the `Box` variants.

### `ActivityStack`

```rust
pub struct ActivityStack<T: Theme, const DEPTH: usize> {
    stack: heapless::Vec<Box<dyn Activity<T>>, DEPTH>,
}

impl<T: Theme, const DEPTH: usize> ActivityStack<T, DEPTH> {
    /// Drive one frame: poll input → dispatch → render → flush.
    /// Returns false when the stack is empty (app should exit/sleep).
    pub fn tick(
        &mut self,
        input: &mut impl InputSource,
        ui: &mut Ui<T>,
    ) -> bool;
}
```

`DEPTH` is a const generic — the maximum activity stack depth is set at compile time. Typical value: 8. No heap allocation for the stack itself.

### `Context`

```rust
/// Passed to Activity lifecycle methods. Provides access to shared state.
pub struct Context<'a, T: Theme> {
    pub theme: &'a T,
    pub screen: Rect,             // full display bounds
    pub settings: &'a mut dyn SettingsStore,
    pub files: &'a mut dyn FileStore,
    // Extensible: users add device-specific fields via a generic parameter
}
```

---

## Layout Engine

Layout is computed **once per scene entry** or on explicit invalidation, not on every render. Stored as a flat array of named `Rect`s. Zero heap allocation.

### Design

Layout is split from rendering deliberately. You compute layout early (in `on_enter` or `on_resume`), store the `Rects`, then reference them in `render()`. This means render is just "draw widget at this rect" — no layout math at render time.

```rust
/// Statically-sized layout result. N is the number of layout slots.
pub struct Layout<const N: usize> {
    rects: [Rect; N],
}

impl<const N: usize> Layout<N> {
    pub fn get(&self, slot: usize) -> Rect;
}
```

### `LayoutBuilder`

```rust
pub struct LayoutBuilder {
    remaining: Rect,
}

impl LayoutBuilder {
    pub fn new(screen: Rect) -> Self;

    /// Carve a fixed-height strip from the top.
    pub fn header(self, height: u16) -> (Rect, Self);

    /// Carve a fixed-height strip from the bottom.
    pub fn footer(self, height: u16) -> (Rect, Self);

    /// Carve a fixed-width strip from the left.
    pub fn sidebar(self, width: u16) -> (Rect, Self);

    /// Apply uniform margin to remaining space.
    pub fn margin(self, h: u16, v: u16) -> Self;

    /// Remaining space after all carves.
    pub fn body(self) -> Rect;

    /// Split remaining space into N equal columns.
    pub fn columns<const N: usize>(self) -> [Rect; N];

    /// Split remaining space into N equal rows.
    pub fn rows<const N: usize>(self) -> [Rect; N];
}
```

**Usage pattern:**

```rust
struct ReaderActivity {
    layout: ReaderLayout,
    // ...
}

struct ReaderLayout {
    status_bar: Rect,
    body: Rect,
    footer: Rect,
}

impl ReaderLayout {
    fn compute(screen: Rect) -> Self {
        let builder = LayoutBuilder::new(screen);
        let (status_bar, builder) = builder.header(32);
        let (footer, builder) = builder.footer(28);
        let body = builder.margin(16, 8).body();
        Self { status_bar, body, footer }
    }
}

fn on_enter(&mut self, ctx: &mut Context<T>) {
    self.layout = ReaderLayout::compute(ctx.screen);
}
```

---

## Render IR and Dirty Tracking

This is the layer that makes `einked` genuinely different for e-ink.

### `DrawCmd`

```rust
/// Backend-agnostic render instruction.
#[derive(Clone)]
pub enum DrawCmd<'a> {
    FillRect  { rect: Rect, color: Color },
    DrawLine  { start: Point, end: Point, color: Color, width: u8 },
    DrawText  { pos: Point, text: &'a str, style: TextStyle },
    DrawGlyph { pos: Point, glyph: GlyphId, style: TextStyle },
    DrawImage { rect: Rect, data: &'a [u8], format: ImageFormat },
    Clip      { rect: Rect },  // push clip rect
    Unclip,                    // pop clip rect
}
```

### `CmdBuffer`

The `Ui` context writes `DrawCmd`s into a fixed-size buffer during `render()`. This buffer is compared to the previous frame's buffer to produce dirty regions.

```rust
pub struct CmdBuffer<const N: usize> {
    cmds: heapless::Vec<DrawCmd<'static>, N>,
    // each cmd tagged with its source rect for dirty region attribution
    regions: heapless::Vec<(Rect, usize), N>,
}
```

`N` is chosen by the user at construction time based on available RAM. A typical reader page = 50–200 commands.

### `DirtyTracker`

```rust
pub struct DirtyTracker {
    /// Regions that changed since last flush, coalesced.
    dirty: heapless::Vec<Rect, 16>,
    /// Whether any dirty region requires a full refresh.
    needs_full: bool,
    /// Count of consecutive partial refreshes (ghosting counter).
    partial_count: u8,
    /// After this many partials, force a full refresh.
    partial_limit: u8,
}

impl DirtyTracker {
    pub fn mark_dirty(&mut self, rect: Rect, requires_full: bool);
    pub fn coalesce(&mut self);
    pub fn is_clean(&self) -> bool;
    pub fn should_full_refresh(&self) -> bool;
    pub fn dirty_regions(&self) -> &[Rect];
    pub fn reset(&mut self);
}
```

The tracker is fed by diffing consecutive `CmdBuffer`s. Commands that changed produce dirty rects. Commands with `RefreshHint::Full` set `needs_full = true`. After `partial_limit` consecutive partial refreshes, `should_full_refresh()` returns true regardless — ghosting cleanup.

---

## Refresh Model

### `RefreshHint`

```rust
/// Attached to activities and individual widgets.
/// The scheduler uses this + DirtyTracker state to decide actual refresh mode.
#[derive(Copy, Clone, Debug, PartialEq)]
pub enum RefreshHint {
    /// Scheduler decides. Usually the right choice.
    Adaptive,
    /// Always do a full refresh for this render. Use for page turns.
    Full,
    /// Prefer partial refresh. Use for status bar updates, progress.
    Partial,
    /// Use the fastest available waveform. Accepts ghosting. Use for fast feedback.
    Fast,
}
```

### `RefreshScheduler`

```rust
pub struct RefreshScheduler {
    tracker: DirtyTracker,
    hint: RefreshHint,
}

impl RefreshScheduler {
    /// Compute the actual refresh mode to use.
    pub fn decide(&self) -> RefreshMode;

    /// Execute: render dirty regions to the display.
    pub fn flush(&mut self, display: &mut impl EinkDisplay, cmds: &CmdBuffer);
}

pub enum RefreshMode {
    Full,
    Partial { regions: &[Rect] },
    Fast    { regions: &[Rect] },
    Skip,   // nothing changed
}
```

### `EinkDisplay` trait

```rust
/// The trait device drivers implement. einked-core never imports a specific driver.
pub trait EinkDisplay {
    fn full_refresh(&mut self, data: &[u8]);
    fn partial_refresh(&mut self, data: &[u8], region: Rect);
    fn fast_refresh(&mut self, data: &[u8], region: Rect);
    fn width(&self) -> u16;
    fn height(&self) -> u16;
}
```

`ssd1677` implements this. So does the SDL simulator. So does the WASM simulator. `einked-core` knows none of them.

---

## Widget System

### `Widget` trait

```rust
pub trait Widget {
    /// Render self into `ui` within `rect`.
    fn render(&self, ui: &mut Ui, rect: Rect);

    /// Preferred size given unlimited space. Used by layout helpers.
    fn size_hint(&self, available: Rect) -> (u16, u16);

    /// The RefreshHint this widget requires. Default: Adaptive.
    fn refresh_hint(&self) -> RefreshHint {
        RefreshHint::Adaptive
    }
}
```

### `InteractiveWidget` trait

```rust
pub trait InteractiveWidget: Widget {
    /// Called when this widget has focus and receives an input event.
    fn on_input(&mut self, event: InputEvent) -> WidgetEvent;

    /// Whether this widget currently has focus.
    fn focused(&self) -> bool;
}

pub enum WidgetEvent {
    Consumed,
    Activated,   // e.g. button pressed
    Changed(i32), // e.g. slider moved
    Ignored,     // pass to parent
}
```

### Built-in Widgets

All widgets are structs that implement `Widget`. They are stack-allocated. No heap.

**Text primitives:**
- `Label<'a>` — single-line text, ellipsis overflow
- `Paragraph<'a>` — multi-line reflowed text, configurable alignment
- `TextFlow<'a>` — paginated text from a `&[Line]` slice, the core reading widget

**Layout containers:**
- `VStack<const N: usize>` — vertical stack of N child widgets with gap
- `HStack<const N: usize>` — horizontal stack of N child widgets with gap
- `Padded<W: Widget>` — wraps a widget with padding

**Controls:**
- `Button<'a>` — focusable, activates on Confirm
- `SelectList<'a, T, const N: usize>` — scrollable list with selection highlight
- `ProgressBar` — horizontal fill bar
- `Checkbox` — boolean toggle

**Display:**
- `Divider` — horizontal or vertical line rule
- `Icon` — renders a 1-bit bitmap from a static `IconSet`
- `StatusBar<'a>` — left + right label layout, fixed height
- `PageIndicator` — `n / total` display, optionally a dot grid

---

## The `ui!` Macro

The primary authoring interface. A proc macro that compiles to a sequence of draw calls with zero runtime overhead. Inspired by Maud's HTML macro.

### Syntax

```rust
ui! {
    VStack gap=8 pad=16 {
        StatusBar {
            left: Label(self.chapter, theme.caption())
            right: Label(self.time, theme.caption())
        }
        Divider
        TextFlow(lines: &self.page_lines, style: theme.body(), fill)
        Spacer
        HStack align=center {
            Icon(BATTERY, self.battery)
            Spacer
            Label(format!("{}/{}", self.page, self.total), theme.caption())
        }
    }
}
```

### Expansion

The macro expands to nested closure calls against the `ui` context:

```rust
ui.vstack(VStackOpts { gap: 8, pad: 16 }, |ui, rect| {
    ui.status_bar(rect, |sb| {
        sb.left(|ui, r| ui.label(r, self.chapter, theme.caption()));
        sb.right(|ui, r| ui.label(r, self.time, theme.caption()));
    });
    ui.divider(rect);
    ui.text_flow(rect, &self.page_lines, theme.body(), FillParent);
    ui.spacer(rect);
    ui.hstack(rect, HStackOpts { align: Align::Center }, |ui, rect| {
        ui.icon(rect, BATTERY, self.battery);
        ui.spacer(rect);
        ui.label(rect, &format!("{}/{}", self.page, self.total), theme.caption());
    });
});
```

No allocations. No tree. The "tree" exists only in the source code.

### Composability

Functions can return `impl Widget` for use inside `ui!`:

```rust
fn page_footer(page: u32, total: u32, battery: u8) -> impl Widget {
    ui! {
        HStack pad=8 align=center {
            Icon(BATTERY, battery)
            Spacer
            Label(format!("{}/{}", page, total), theme.caption())
        }
    }
}

// Used as:
ui! {
    VStack {
        TextFlow(lines: &self.lines, style: theme.body(), fill)
        page_footer(self.page, self.total, self.battery)
    }
}
```

The returned value is a closure — a zero-sized type in most cases. The compiler inlines everything.

### Refresh Annotations

Widgets can be annotated with refresh hints inline:

```rust
ui! {
    VStack {
        #[refresh = Full]
        TextFlow(lines: &self.lines, style: theme.body(), fill)

        #[refresh = Partial]
        HStack {
            Label(self.status, theme.caption())
        }
    }
}
```

The annotation attaches to the enclosing widget's `DrawCmd` region. The `DirtyTracker` reads this when deciding refresh mode.

---

## Font Pipeline

Handled by `einked-fonts`, which `einked-core` knows only through a trait.

### `GlyphRasterizer` trait

```rust
/// einked-core's view of the font system.
pub trait GlyphRasterizer {
    fn rasterize(&mut self, c: char, style: TextStyle) -> Option<GlyphBitmap>;
    fn metrics(&self, style: TextStyle) -> FontMetrics;
    fn measure_str(&self, s: &str, style: TextStyle) -> (u16, u16);
}

pub struct FontMetrics {
    pub ascent: i16,
    pub descent: i16,
    pub line_height: u16,
    pub cap_height: u16,
}

pub struct GlyphBitmap {
    pub width: u8,
    pub height: u8,
    pub bearing_x: i8,
    pub bearing_y: i8,
    pub advance: u8,
    pub data: &'static [u8],  // 1bpp packed, or reference into cache
}
```

### `einked-fonts`: `FontdueRasterizer`

The concrete implementation using `fontdue`:

```rust
pub struct FontdueRasterizer<const CACHE_GLYPHS: usize> {
    fonts: heapless::Vec<fontdue::Font, 8>,
    cache: LruGlyphCache<CACHE_GLYPHS>,
}

impl<const N: usize> GlyphRasterizer for FontdueRasterizer<N> { ... }
```

`CACHE_GLYPHS` controls LRU cache size at compile time. Typical: 256 glyphs. Each cached glyph: ~64 bytes average → 256 glyphs = ~16KB. Configurable based on available RAM.

### Dithering

E-ink displays with gray capability use dithering to render intermediate values. `einked-fonts` provides Floyd-Steinberg dithering as an optional step between rasterization and output. For 1-bit displays (like the SSD1677 in B&W mode), subpixel antialiasing is thresholded to 1-bit.

---

## Storage and Settings Traits

Thin traits that let `einked-core` activities interact with storage without knowing the hardware.

```rust
pub trait FileStore {
    type Error;
    fn list(&self, path: &str, out: &mut dyn FnMut(&str));
    fn read<'a>(&self, path: &str, buf: &'a mut [u8]) -> Result<&'a [u8], Self::Error>;
    fn exists(&self, path: &str) -> bool;
}

pub trait SettingsStore {
    fn load_raw(&self, key: u8, buf: &mut [u8]) -> usize;
    fn save_raw(&mut self, key: u8, data: &[u8]);
}
```

Simple byte-level interfaces. Activities serialize/deserialize their own settings. No schema, no JSON — `postcard` or `bytemuck` for zero-copy serialization.

---

## Simulator Support

`einked-core` compiles for all targets. Simulators implement `EinkDisplay` and `InputSource`:

```rust
// Desktop (SDL2)
pub struct SdlDisplay { ... }
impl EinkDisplay for SdlDisplay { ... }

pub struct SdlInput { ... }
impl InputSource for SdlInput { ... }

// Web (WASM)
pub struct CanvasDisplay { ... }
impl EinkDisplay for CanvasDisplay { ... }
```

The firmware binary and the simulator binary share identical activity code. The only difference is which `EinkDisplay` and `InputSource` they construct at startup. This is the primary developer workflow — build and iterate in the simulator, flash when ready.

---

## Memory Budget

Target: workable on 327KB usable RAM (ESP32-C3 with SSD1677 480×800).

| Component | Budget |
|---|---|
| Framebuffer (1-bit, 480×800) | 48 KB |
| Previous frame buffer (for diffing) | 48 KB |
| Glyph cache (256 glyphs × ~64B avg) | 16 KB |
| CmdBuffer (200 cmds × ~32B) | 6 KB |
| Activity stack (8 activities × ~4KB each) | 32 KB |
| Text layout line buffer | 8 KB |
| epub-stream streaming parser | 60 KB |
| **Total** | **~218 KB** |
| **Headroom** | **~109 KB** |

Actual activity state varies by activity. The reader activity is the largest. The above is a worst-case estimate with the reader active.

Knobs: `CACHE_GLYPHS`, `CmdBuffer N`, `DEPTH` (activity stack depth) are all const generics that let users tune memory usage for their device.

---

## Feature Flags

| Feature | Enables |
|---|---|
| `alloc` | `Box`-based `Push`/`Replace` transitions, `String` convenience methods |
| `defmt` | `defmt`-compatible logging and `#[derive(Format)]` on core types |
| `std` | `std::error::Error` impls, used by simulators and desktop tooling |
| `fontdue` | `FontdueRasterizer` in `einked-fonts` |
| `dithering` | Floyd-Steinberg dithering in font pipeline |

Default features: none. Everything opt-in.

---

## What `einked` Is Not

- Not a reactive framework. There is no state diffing, no signals, no subscriptions. State management is the activity's responsibility.
- Not a general embedded UI toolkit. It is designed for text-content interfaces on e-ink. It will work on LCD but isn't optimized for it.
- Not a layout engine that runs continuously. Layout runs once. Render is draw calls. This is a feature.
- Not allocation-free in all configurations. The `no_alloc` path is supported and tested, but the `alloc` path is the comfortable default for simulator development.

---

## Non-Goals (v1)

- Animations (meaningless on most e-ink panels)
- Touch input (future: `InputEvent::Touch(x, y)` extension point exists)
- Color beyond BWR tri-color
- GPU acceleration
- Accessibility APIs
- Right-to-left text

---

## Open Questions

1. **`no_alloc` Push:** Static activity pool vs. enum dispatch vs. `&'static dyn ActivityFactory` — needs a prototype before committing.
2. **Macro vs. builder:** Should `ui!` be a proc macro or a fluent builder API? Proc macro gives the best syntax but adds a proc macro crate dependency. A builder is less pretty but simpler to implement and debug. Recommend: implement builder first, add macro as a skin once the API is stable.
3. **Glyph cache eviction:** LRU is the default. For e-readers, a page-scoped cache (evict all at page turn) may outperform LRU since the glyph working set changes entirely at each page turn.
4. **Font embedding:** `build.rs` + `include_bytes!` is the current approach. A `einked_fonts!` macro that validates font files at compile time would be a better DX.
5. **Settings schema:** Currently raw `u8` keys. A typed settings macro (`settings! { font_size: u8 = 16, line_spacing: f32 = 1.4 }`) would eliminate boilerplate in every activity.
